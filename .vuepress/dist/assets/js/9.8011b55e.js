(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{123:function(a,t,r){"use strict";r.r(t);var v=r(0),e=Object(v.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"java内存区域与内存溢出异常"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java内存区域与内存溢出异常","aria-hidden":"true"}},[a._v("#")]),a._v(" Java内存区域与内存溢出异常")]),a._v(" "),r("p",[a._v("​\tJava的自动内存管理对于程序猿来说十分方便，我们不需要去手动的释放对象，也不容易出现内存泄漏和内存溢出的问题，但是如果出现了内存泄漏和内存溢出，我们在不了解JVM是如何使用内存的，排除错误是一件十分有挑战性的事情，因此需要对JVM内存管理有一定的了解。")]),a._v(" "),r("h3",{attrs:{id:"运行时数据区域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区域","aria-hidden":"true"}},[a._v("#")]),a._v(" 运行时数据区域")]),a._v(" "),r("p",[a._v("​\t首先需要了解的是Java虚拟机，在执行过程中，将内存划分的区域，以及各个区域的创建、用途、销毁，根据JVM的规定，JVM需要管理的内存区域有以下的几个部分。")]),a._v(" "),r("p",[a._v("运行时数据区：")]),a._v(" "),r("ul",[r("li",[r("h5",{attrs:{id:"方法区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区","aria-hidden":"true"}},[a._v("#")]),a._v(" 方法区")])]),a._v(" "),r("li",[r("h5",{attrs:{id:"堆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆","aria-hidden":"true"}},[a._v("#")]),a._v(" 堆")])]),a._v(" "),r("li",[r("h5",{attrs:{id:"虚拟机栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈","aria-hidden":"true"}},[a._v("#")]),a._v(" 虚拟机栈")])]),a._v(" "),r("li",[r("h5",{attrs:{id:"本地方法栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈","aria-hidden":"true"}},[a._v("#")]),a._v(" 本地方法栈")])]),a._v(" "),r("li",[r("h5",{attrs:{id:"程序计数器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器","aria-hidden":"true"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),r("p",[a._v("其中方法区和堆是线程共享的，虚拟机栈、本地方法栈和程序计数器是线程隔离的。")]),a._v(" "),r("p",[a._v("在不同版本的JDK有不同的划分：")]),a._v(" "),r("h5",{attrs:{id:"jdk1-8之前："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-8之前：","aria-hidden":"true"}},[a._v("#")]),a._v(" JDK1.8之前：")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png",alt:"img"}})])])]),a._v(" "),r("h5",{attrs:{id:"jdk1-8之后"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-8之后","aria-hidden":"true"}},[a._v("#")]),a._v(" JDK1.8之后")]),a._v(" "),r("div",{attrs:{align:"center"}},[r("img",{attrs:{src:"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3Java运行时数据区域JDK1.8.png",width:"600px"}})]),a._v(" "),r("h4",{attrs:{id:"程序计数器-pc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器-pc","aria-hidden":"true"}},[a._v("#")]),a._v(" 程序计数器 PC")]),a._v(" "),r("p",[a._v("​\t这块内存区域较小，PC是当前线程所执行的字节码行号指示器，在虚拟机的概念模型中，字节码解释器工作时会通过改变这个计数器的值来选取下一条执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。")]),a._v(" "),r("p",[a._v("​\t每个线程都有一个独立的程序计数器，因此程序计数器是线程私有的，不会互相影响。")]),a._v(" "),r("p",[a._v("​\t如果线程正在执行的是一个Java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。这个内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。")]),a._v(" "),r("h4",{attrs:{id:"java虚拟机栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈","aria-hidden":"true"}},[a._v("#")]),a._v(" Java虚拟机栈")]),a._v(" "),r("p",[a._v("​\t与程序计数器，Java虚拟机栈是线程私有的，与线程的生命周期相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时，会创建一个栈帧。")]),a._v(" "),r("p",[a._v("​\t栈帧会保存，局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。")]),a._v(" "),r("p",[a._v("​\tJava方法如果返回或抛出异常，就会出栈。")]),a._v(" "),r("p",[a._v("​\t虚拟机栈中的局部变量表存放着各种基本数据类型（boolean,byte,char,short,int,float,long,double）、还包括了对象引用(refernce类型)，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个对象代表的句柄或其他与此对象有关的位置）还有一个returnAddress类型，(指向了一条字节码地址)")]),a._v(" "),r("p",[a._v("​\t其中long和double类型的数据会占用2个局部变量slot，其余的数据类型只占用一个，局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的。")]),a._v(" "),r("p",[a._v("​\t在java虚拟机中，对这个区域规定了两种异常：如果线程请求的栈深度大于虚拟机所规定的深度，将会抛出StackOverFlowError异常；如果虚拟机栈可以动态扩展，但是剩余内存不足以开辟空间，会抛出OutOfMemoryError异常。")]),a._v(" "),r("h4",{attrs:{id:"本地方法栈-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),r("p",[a._v("​\t本地方法栈的用途和作用于Java虚拟机栈是一致的，只不过本地方法栈会保存Native方法，这个对语言与所使用的数据结构并没有强制的要求，甚至在sun HotSpot虚拟机将本地方法和虚拟机栈合二为一。")]),a._v(" "),r("h4",{attrs:{id:"java堆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java堆","aria-hidden":"true"}},[a._v("#")]),a._v(" Java堆")]),a._v(" "),r("p",[a._v("​\t对于大多数的应用来说，Java堆是最大的一块内存区域，是虚拟机栈管理的最大的一块内存区域。Java堆会被所有线程共享，在虚拟机启动时，Java堆的用途就是存放Java对象，几乎所有的对象都在这里分配内存。")]),a._v(" "),r("p",[a._v("​\t在虚拟机规范中，Java对象实例和数组都在堆上分配内存，但是随着Jit编译器的发展与逃逸分析技术成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所以我们可以说，所有的对象在堆上分配内存不那么绝对了。")]),a._v(" "),r("p",[a._v("​\tJava堆是垃圾收集器的主要区域，从内存回收的角度看，由于很多的垃圾回收算法采用了分代回收，因此我们会分为Eden空间，From Survivor空间、TO Survivor空间等等。但是从内存分配的角度看，线程共享的堆内存有部分会被划分为多线程私有的分配缓存区，Thread Local Allocation Buffer 。不过无论如何划分，都与存放内容无关，无论哪个区域存储的东西任然是对象实例")]),a._v(" "),r("p",[a._v("​\tJava堆的大小可以通过-Xmx 和 -Xms控制，如果在堆内存空间不足，且无法再申请到更多内存时，会抛出OutOfMemoryError的异常。")]),a._v(" "),r("h4",{attrs:{id:"方法区-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),r("p",[a._v("​\t方法区和堆一样，是各个线程共享的区域，它用于存储被加载的类信息，常量，静态变量，即时编译器编译出的代码等。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 "),r("strong",[a._v("Non-Heap（非堆）")]),a._v("，目的应该是与 Java 堆区分开来。")]),a._v(" "),r("h5",{attrs:{id:"方法区和永久代的关系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区和永久代的关系","aria-hidden":"true"}},[a._v("#")]),a._v(" 方法区和永久代的关系")]),a._v(" "),r("blockquote",[r("p",[a._v("《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。  "),r("strong",[a._v("方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。")]),a._v(" 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。")])]),a._v(" "),r("h4",{attrs:{id:"运行时常量池"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池","aria-hidden":"true"}},[a._v("#")]),a._v(" 运行时常量池")]),a._v(" "),r("p",[a._v("​\t运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）")]),a._v(" "),r("p",[a._v("​\t既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。")]),a._v(" "),r("h4",{attrs:{id:"直接内存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#直接内存","aria-hidden":"true"}},[a._v("#")]),a._v(" 直接内存")]),a._v(" "),r("p",[r("strong",[a._v("直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。")])]),a._v(" "),r("p",[a._v("​\tJDK1.4 中新加入的 "),r("strong",[a._v("NIO(New Input/Output) 类")]),a._v("，引入了一种基于"),r("strong",[a._v("通道（Channel）")]),a._v(" 与"),r("strong",[a._v("缓存区（Buffer）")]),a._v(" 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为"),r("strong",[a._v("避免了在 Java 堆和 Native 堆之间来回复制数据")]),a._v("。")]),a._v(" "),r("p",[a._v("​\t本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。")]),a._v(" "),r("h3",{attrs:{id:"hotspot中的对象揭秘"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hotspot中的对象揭秘","aria-hidden":"true"}},[a._v("#")]),a._v(" HotSpot中的对象揭秘")]),a._v(" "),r("h5",{attrs:{id:"待续"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#待续","aria-hidden":"true"}},[a._v("#")]),a._v(" 待续......")]),a._v(" "),r("h3",{attrs:{id:"oom异常"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#oom异常","aria-hidden":"true"}},[a._v("#")]),a._v(" OOM异常")])])},[],!1,null,null,null);t.default=e.exports}}]);